title: "无聊 crackme"
date: 2016-11-03 16:23:12
categories: android
tags: [android, crack, smali, idea]
toc: true
description: 最近超级想打球，然后打了五分钟就把脚踝给扭伤了。原以为10月已经够悲伤了，没想到11月还倒霉。还好还有一群小伙伴。在寝室休息了两天，动不了，想起了之前kindle下的好几本书都没看，看了一半的《白夜行》（还不错，手贱先百度了剧情。。。。。雪穗），然后有个比我更无聊的人，发了一个网址给我。。。

---

## 0x00 简介
题目其实很简单，通过破解[CrackMe.apk](https://github.com/gnaixx/gnaixx.github.io/files/573115/CrackMe.apk.zip)获取一个key。但是之前没尝试过用 idea 动态调试 smali 代码，刚好记录一下。

## 0x01 工具介绍
- apktool: 反编译apk，得到 smali 代码
- Android Studio: 调试 smali 代码工具，用 idea 也一样
- smalidea-003.zip: idea 插件，下载地址 [smalidea-003.zip](https://bitbucket.org/JesusFreke/smali/downloads)

## 0x02 逆向过程
题目提示的很清楚破解 apk 找到隐藏的 flag。

### 利用apktool反编译 smali 代码
执行：

```bash
apktool d -o crackme CrackMe.apk
```
反编译后crackme 文件目录：

```bash
→ tree -L 1
.
├── AndroidManifest.xml
├── apktool.yml
├── assets
├── build
├── crackme.iml
├── dist
├── gen
├── original
├── res
└── smali
```
smali 目录就是接下里动态调试的代码。

### 修改menifest.xml
动态调试需要apk支持 debug。所以我们需要修改一下：

```xml
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.suctf.crackme" platformBuildVersionCode="23" platformBuildVersionName="6.0-2704002">
    <application android:allowBackup="true" android:debuggable="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:name="com.suctf.crackme.App" android:supportsRtl="true" android:theme="@style/AppTheme">
        <activity android:name="com.suctf.crackme.MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
    </application>
</manifest>

```

在 <application> 标签中添加 `android:debuggable="true"`

修改后需要用 apktool 进行回编，并用 auto-sign 重新签名，这里不做具体介绍了。

## 0x03 代码分析
在开始调试代码前需要分析一下源码的逻辑，因为没有混淆，可以比较轻易的分析。

利用 jadx-gui 反编译 Java 源码，当然也可以用 smali 工具反编译回 java。

MainActivity.class:

```java
public class MainActivity extends AppCompatActivity {
    Button btn;
    String correct = "XclSH6nZEPVd41FsAsqeChz6Uy+HFzV8Cl9jqMyg6mMrcgSoM0vJtA1BpApYahCY";
    Encrypt encrypt;
    EditText flagText;
    ImageView imageView;

    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView((int) R.layout.activity_main);
        this.imageView = (ImageView) findViewById(R.id.imageView);
        this.flagText = (EditText) findViewById(R.id.flagText);
        this.encrypt = new Encrypt();
        this.btn = (Button) findViewById(R.id.button);
        try {
            this.imageView.setImageBitmap(BitmapFactory.decodeStream(getAssets().open("kawai.jpg")));
        } catch (Exception e) {
        }
        this.btn.setOnClickListener(new OnClickListener() {
            public void onClick(View view) {
                if (MainActivity.this.encrypt.doEncrypt(MainActivity.this.flagText.getText().toString()).equals(MainActivity.this.correct)) {
                    Toast.makeText(MainActivity.this.getApplicationContext(), "Correct!", 1).show();
                } else {
                    Toast.makeText(MainActivity.this.getApplicationContext(), "Wrong!", 1).show();
                }
            }
        });
    }
}
```

Encrypt.class：

```java
public class Encrypt {
    private String key = "3b0de20546e9331c7c87aaabf9d0d4afd8c8a761";

	//点击CRACK调用该函数，需要注意加密后值进行了一次base64
    public String doEncrypt(String source) {
        try {
            char[] iv = new char[16];
            BufferedReader reader = new BufferedReader(new InputStreamReader(ContextHolder.getContext().getAssets().open("kawai.jpg")));
            reader.skip(424);
            reader.read(iv);
            reader.close();
            return Base64.encodeToString(encrypt(source.getBytes(), this.key.getBytes(), charArrayToByteArray(iv)), 2);
        } catch (Exception e) {
            e.printStackTrace();
            return BuildConfig.FLAVOR;
        }
    }

    private byte[] charArrayToByteArray(char[] chars) {
        byte[] ret = new byte[chars.length];
        for (int i = 0; i < chars.length; i++) {
            ret[i] = (byte) chars[i];
        }
        return ret;
    }
    
	//破解的关键，只需要知道key, IV.就可以通过AES解密出 flag
    public byte[] encrypt(byte[] source, byte[] key, byte[] IV) throws Exception {
        byte[] realKey = transformKey(key);
        Cipher cipher = Cipher.getInstance("AES/CFB/PKCS7Padding");
        cipher.init(1, new SecretKeySpec(realKey, "AES"), new IvParameterSpec(IV));
        return cipher.doFinal(source);
    }

    private byte[] transformKey(byte[] key) {
        int i;
        byte[] allKey = new byte[32];
        char[] pwd = new char[32];
        if (key.length >= 32) {
            for (i = 0; i < 32; i++) {
                allKey[i] = key[i];
            }
        } else {
            for (i = 0; i < key.length; i++) {
                allKey[i] = key[i];
            }
            for (i = key.length; i < 32; i++) {
                allKey[i] = (byte) i;
            }
        }
        try {
            BufferedReader reader = new BufferedReader(new InputStreamReader(ContextHolder.getContext().getAssets().open("kawai.jpg")));
            reader.skip(1023);
            reader.read(pwd);
            reader.close();
            for (i = 0; i < 32; i++) {
                allKey[i] = (byte) (allKey[i] ^ pwd[i]);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return allKey;
    }
}
```

apk 的逻辑很简单，填写一个flag，点击 CRACK 按钮，将 flag 通过 `Encrypt.doEncrypt`函数进行加密，将加密后的值与 MainActivity中 `String correct = "XclSH6nZEPVd41FsAsqeChz6Uy+HFzV8Cl9jqMyg6mMrcgSoM0vJtA1BpApYahCY"`进行比较。

关键的函数是 `Encrypt.encrypt`,这个函数有三个参数 source, key, IV。source 是输入的 flag 值， key是`3b0de20546e9331c7c87aaabf9d0d4afd8c8a761`, IV 是通过"kawai.jpg" 获取的。需要注意的是 函数内有个realKey，AES的秘钥其实由它和IV生成的。

所以只需要在 `Cipher cipher = Cipher.getInstance("AES/CFB/PKCS7Padding");`下个断点，获取到realKey, IV。那么就可以知道 flag了。

## 0x04 动态分析
### 导入插件
导入之前下载好的 smalidea-003.zip。

### 导入 smali 代码

![](https://gnaixx.github.io/blog_images/crackme/5.png)

选择上面反编译的 smali 目录。最后导入的项目：

![](https://gnaixx.github.io/blog_images/crackme/6.png)

### 设置调试
**1.配置AS调试配置**

Run->Edit Configurations, 点击+号，新建 Remote 类型调试，设置name, 修改端口号（本次设置为8800）。

![](https://gnaixx.github.io/blog_images/crackme/7.png)

**2.配置端口**

![](https://gnaixx.github.io/blog_images/crackme/8.png)

- 在AS的终端以调试模式启动应用，进程挂起，此时运行命令查看该应用的进程号为1667
- 设置端口转发，在本地8800端口与手机1667进程之间建立一条通道，当开始调试时，AS连接本地的8800端口，通过这条通道控制程序的运行

**3.下断点**

需要注意的是，smali并不是每一行都可以下断点，当下断点没有成功时，选择其他地方下断点测试。

**4.调试**

![](https://gnaixx.github.io/blog_images/crackme/9.png)
Run->Debug 选择刚才新增的调试器，此时程序会断在设置的断点的行，这时候已经可以直接看到 realKey 跟 IV的值了。

## 0x05 编写解密程序
通过上面的动态调试，已经知道了 AES 加密的秘钥跟加密后的密文，剩下的就是写一个简单的AES解密算法了。

```java
public void decrypt() {
    byte[] realKey = new byte[]{46, 121, 19, 74, -104, 25, -51, -56, 73, -53, -104, -60, 73, -50, -52, -98, -54, -98, 104, -54, -100, 27, -100, 5, -101, 46, -103, -51, 10, -55, 62, -101};
    byte[] IV = new byte[]{13, 14, 13, 16, 14, 14, 16, 20, 14, 14, 14, 20, 20, 14, 14, 14};
    String source = "XclSH6nZEPVd41FsAsqeChz6Uy+HFzV8Cl9jqMyg6mMrcgSoM0vJtA1BpApYahCY";
   
    try {
        byte[] targeSource = Base64.decode(source, Base64.NO_WRAP);
        Cipher cipher = Cipher.getInstance("AES/CFB/PKCS7Padding");
        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(realKey, "AES"), new IvParameterSpec(IV));
        byte[] pwd = cipher.doFinal(targeSource);
        Log.d("gnaixx", new String(pwd));
    } catch (Exception e) {
        e.printStackTrace();
} 
```
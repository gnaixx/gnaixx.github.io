---
title: Xposed Hook 原理和检测方法
tags: [android, hook, xposed]
toc: true
date: 2017-08-27 14:18:56
categories: android
description: xposed 应该是应用最多的 Android hook框架了。插件开发成本相对比较低，并且能直接打包成 apk 发给普通用户使用。通过梳理 xposed 的实现原理，对与 hook 检测会有不少新的思路。

---

## 0x00 Xposed 简介
> Xposed is a framework for modules that can change the behavior of the system and apps without touching any APKs. That's great because it means that modules can work for different versions and even ROMs without any changes (as long as the original code was not changed too much). It's also easy to undo. As all changes are done in the memory, you just need to deactivate the module and reboot to get your original system back. There are many other advantages, but here is just one more: Multiple modules can do changes to the same part of the system or app. With modified APKs, you to decide for one. No way to combine them, unless the author builds multiple APKs with different combinations.

官方网站:[http://repo.xposed.info/](http://repo.xposed.info/)    
Xposed源码:[https://github.com/rovo89](https://github.com/rovo89)

要正常运行 Xposed 需要以下的几个模块:

- XposedBridge.jar: 负责在 Native 层和 Framework 层进行交互。Module 开发就是基于该 jar 包。
- Xposed 模块: Xposed 的 C++ 部分，主要是用来替换 /system/bin/app_process,并注入 XposedBridge.jar。同时为 XposedBride 提供 JNI 方法。
- XposedInstaller: Xposed 的安装包，负责 Module 的管理。
- XposedModule: Xposed 插件, 想要 hook 一些东西，就需要自己开发一个插件。
-  android_art（art）: 应用 art 和 dalvik 实现的 hook 方式不一样，作者对  libart.so 进行了重写。

## 0x01 插件开发 
  在将原理前先看下怎么开发插件会比较好的理解入口，安装好 xposed 框架后开发插件其实很简单。
  
**1.创建一个 Android 项目**

普通的 Android 项目就可以。

**2.引入 Xposed Framework API**

```xml
dependencies {
  provided 'de.robv.android.xposed:api:82'
  //如果需要引入文档，方便查看的话
  provided 'de.robv.android.xposed:api:82:sources'
}
```
相关文档：

- [https://bintray.com/rovo89/de.robv.android.xposed/api](https://bintray.com/rovo89/de.robv.android.xposed/api)
- [http://api.xposed.info/reference/packages.html](http://api.xposed.info/reference/packages.html)

**3.修改 AndroidManifest.xml**

```xml
<application
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name" >
        <meta-data
            android:name="xposedmodule"
            android:value="true" />
        <meta-data
            android:name="xposeddescription"
            android:value="description" />
        <meta-data
            android:name="xposedminversion"
            android:value="53" />
</application>
```

**4.Hook 实现**

创建一个类并集成 IXposedHookLoadPackage 接口:

```java
package com.example.xposed_plugin;

import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;
import de.robv.android.xposed.IXposedHookLoadPackage;
import de.robv.android.xposed.XC_MethodHook;
import de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;

public class TutorialAnt implements IXposedHookLoadPackage {
    public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {
        if (!lpparam.packageName.equals("com.example.gnaixx.antihook"))
            return;

        findAndHookMethod("com.example.gnaixx.antihook.util.TestUtil", lpparam.classLoader, "test1", new XC_MethodHook() {
            @Override
            protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                // this will be called before the clock was updated by the original method
            }
            @Override
            protected void afterHookedMethod(MethodHookParam param) throws Throwable {
                // this will be called after the clock was updated by the original method
            }
    });
    }
}
```

**5.声明实现**

在 assets 目录下创建一个空文件，命名为 xposed_init。这个文件每一行记录一个 Hook 实现类的完整路径。

```txt
com.example.xposed_plugin.TutorialAnt
```
到这里一个 Xposed 插件就可以安装使用了。

## 0x03 XposedBridge 实现分析

### 1.Method Hook

从开发过程中可以发现 `findAndHookMethod()` 作为一个 hook 的入口函数，以这个点开始分析：

**XposedHelpers.java**

```java
	//入口
	public static XC_MethodHook.Unhook findAndHookMethod(String className, ClassLoader classLoader, String methodName, Object... parameterTypesAndCallback) {
		return findAndHookMethod(findClass(className, classLoader), methodName, parameterTypesAndCallback);
	}
	
	//参数校验
	public static XC_MethodHook.Unhook findAndHookMethod(Class<?> clazz, String methodName, Object... parameterTypesAndCallback) {
		//...

		XC_MethodHook callback = (XC_MethodHook) parameterTypesAndCallback[parameterTypesAndCallback.length-1];
		Method m = findMethodExact(clazz, methodName, getParameterClasses(clazz.getClassLoader(), parameterTypesAndCallback));

		return XposedBridge.hookMethod(m, callback);
	}

	//获取被 hook 函数 Method
	public static Method findMethodExact(Class<?> clazz, String methodName, Class<?>... parameterTypes) {
		String fullMethodName = clazz.getName() + '#' + methodName + getParametersString(parameterTypes) + "#exact";

		if (methodCache.containsKey(fullMethodName)) {
			Method method = methodCache.get(fullMethodName);
			if (method == null)
				throw new NoSuchMethodError(fullMethodName);
			return method;
		}
		//...
	}
```
主线程主要是三个函数的调用 findAndHookMethod -> findAndHookMethod -> XposedBridge.hookMethod。 **findMethodExact** 函数有个变量需要关注 `methodCache`，这个变量保存了所有被 Hook 函数的全称。

**XposedBridge.java**

```java
	//组织参数
	public static XC_MethodHook.Unhook hookMethod(Member hookMethod, XC_MethodHook callback) {
		//...

		boolean newMethod = false;
		CopyOnWriteSortedSet<XC_MethodHook> callbacks;
		synchronized (sHookedMethodCallbacks) {
			callbacks = sHookedMethodCallbacks.get(hookMethod);
			if (callbacks == null) {
				callbacks = new CopyOnWriteSortedSet<>();
				sHookedMethodCallbacks.put(hookMethod, callbacks); //保存了被 hook 函数的所有 callback 方法
				newMethod = true;
			}
		}
		callbacks.add(callback);

		if (newMethod) {
			Class<?> declaringClass = hookMethod.getDeclaringClass();
			int slot;
			Class<?>[] parameterTypes;
			Class<?> returnType;
			if (runtime == RUNTIME_ART) {
				slot = 0;
				parameterTypes = null;
				returnType = null;
			} else if (hookMethod instanceof Method) {
				slot = getIntField(hookMethod, "slot"); //dalvik 可以通过 slot 找到对应的方法指针
				parameterTypes = ((Method) hookMethod).getParameterTypes();
				returnType = ((Method) hookMethod).getReturnType();
			} else {
				slot = getIntField(hookMethod, "slot");
				parameterTypes = ((Constructor<?>) hookMethod).getParameterTypes();
				returnType = null;
			}

			AdditionalHookInfo additionalInfo = new AdditionalHookInfo(callbacks, parameterTypes, returnType);
			hookMethodNative(hookMethod, declaringClass, slot, additionalInfo);
		}

		return callback.new Unhook(hookMethod);
	}
	
	//native 方法
	private native synchronized static void hookMethodNative(Member method, Class<?> declaringClass, int slot, Object additionalInfo);
```
这里有个比较关键的字段 **sHookedMethodCallbacks**,它保存了被 hook 函数的所有回调函数，就是在开发插件的时候我们定义的 beforeHookedMethod 和 afterHookedMethod。

到这里 XposedBridge 部分其实就已经结束了，相对比较简单。还有一个关键的函数 **XposedBridge.handleHookedMethod**,他就是函数在调用的时候执行 callback 的关键。

###2.Field Hook
成员变量的 hook 相对比较简单，主要是通过放射相关的代码进行 Hook。

```java
	public static Field findField(Class<?> clazz, String fieldName) {
		String fullFieldName = clazz.getName() + '#' + fieldName;

		if (fieldCache.containsKey(fullFieldName)) { //保存了所有被 hook 的字段名称
			Field field = fieldCache.get(fullFieldName);
			if (field == null)
				throw new NoSuchFieldError(fullFieldName);
			return field;
		}
		//...
	}
```
可以看到 fieldCache 变量和 methodCache 一样保存了被 hook 的相关字段全称。

## 0x04 Xposed Native 分析
Native 部分分为两块，一块是 app_process 的代码，一部分是 xposed_dalvik/art.so 的代码。

### 1.app_process 替换和 libxposed_dalvik/art.so注入
app_process 也叫做 zygote 进程，是 Android 开启的第一个进程，后续的应用进程都是由该进程孵化的。zygote 进程再启动中会创建 dalvik 虚拟机实例，并加载 java 运行库。

在安装 Xposed 的时候，会替换掉原来的 app_process，并将 XposedBridge.jar 加入到 system/framework/，将 libxposed_dalvik/art.so 复制到 /system/lib , 如果是 art 虚拟机，还会替换 libart.so。

可以先看下简单的流程图：  
![app_process 流程](/blog_images/20170827/app_process.png)

zygote 进程有个 main 函数(以app_main.cpp为例, app_main.cpp为 dalvik, app_main2.cpp 为 art)：

**main(int, char* const[])**

```c++
int main(int argc, char* const argv[])
{
    //...
    
    AppRuntime runtime;
    //...

	//初始化xposed
    isXposedLoaded = xposed::initialize(zygote, startSystemServer, className, argc, argv);
    if (zygote) {
    	//加载 AndroidRuntime 启动 Dalvik/Art 和 xposed
        runtime.start(isXposedLoaded ? XPOSED_CLASS_DOTS_ZYGOTE : "com.android.internal.os.ZygoteInit",
                startSystemServer ? "start-system-server" : "");
    } else if (className) {
        // Remainder of args get passed to startup class main()
        runtime.mClassName = className;
        runtime.mArgC = argc - i;
        runtime.mArgV = argv + i;
        runtime.start(isXposedLoaded ? XPOSED_CLASS_DOTS_TOOLS : "com.android.internal.os.RuntimeInit",
                application ? "application" : "tool");
    } else {
        fprintf(stderr, "Error: no class name or --zygote supplied.\n");
        app_usage();
        LOG_ALWAYS_FATAL("app_process: no class name or --zygote supplied.");
        return 10;
    }
}
```

initialize 主要是将 XposedBridge.jar 加到环境变量中，这样任意 App 打开的时候都会加载该 jar。

**xposed::initialize(bool, bool, const char*, int, char* const[])**

```c++
bool initialize(bool zygote, bool startSystemServer, const char* className, int argc, char* const argv[]) {
	//Initialize Xposed (unless it is disabled).
	//...
	
    return addJarToClasspath();
}
```

**addJarToClasspath()**

```c++
bool addJarToClasspath() {
    ALOGI("-----------------");
    if (access(XPOSED_JAR, R_OK) == 0) {
    	//XPOSED_JAR="/system/framework/XposedBridge.jar"
        if (!addPathToEnv("CLASSPATH", XPOSED_JAR)) 
            return false;

        ALOGI("Added Xposed (%s) to CLASSPATH", XPOSED_JAR);
        return true;
    } else {
        ALOGE("ERROR: Could not access Xposed jar '%s'", XPOSED_JAR);
        return false;
    }
}
```
到这里每个 app 打开的时候就会被注入 XposedBridge.jar。

在回到 main 方法中，接下来就执行了 runtime.start。runtime 是 AppRuntime 对象并继承了 AnroidRuntime。

**AppRuntime**

```c++
class AppRuntime : public AndroidRuntime
{
public:
    AppRuntime()
        : mParentDir(NULL)
        , mClassName(NULL)
        , mClass(NULL)
        , mArgC(0)
        , mArgV(NULL)
    {}

    const char* getClassName() const{ //...}

    virtual void onVmCreated(JNIEnv* env)
    {
        if (isXposedLoaded)
            xposed::onVmCreated(env); //注册 XposedBridge 相关 JNI 函数
        //...
    }

    virtual void onStarted(){//..}

    virtual void onZygoteInit(){//...}

    virtual void onExit(int code){//...}
	//...
};
```
可以看出来定义中并没有实现 start 函数，所以 start 方法应该是在 AndroidRuntime 中，查看 AndroidRuntime.cpp 源码（需要自己搜索）可以发现 start 方法中有调用 **onVmCreated**, 而 AndroidRuntime.onVmCreated 的实现是空的。   

**AndroidRuntime.cpp**

```c++

void AndroidRuntime::start(const char* className, const char* options)
{
    ALOGD("\n>>>>>> AndroidRuntime START %s <<<<<<\n",
            className != NULL ? className : "(unknown)");
    //...
    
    onVmCreated(env);
    //...
}

void AndroidRuntime::onVmCreated(JNIEnv* env)
{
    // If AndroidRuntime had anything to do here, we'd have done it in 'start'.
}
```
但是 AppRuntime 中定义了 vitual void onVmCreated(JNIEnv* env), 所以最后又回到了 AppRuntime.onVmCreated。AppRuntime.onVmCreated 又调用了 xposed::onVmCreated

**xposed::onVmCreated(JNIEnv* )**

```c++
void onVmCreated(JNIEnv* env) {
    // Determine the currently active runtime
    const char* xposedLibPath = NULL;
    if (!determineRuntime(&xposedLibPath)) { //判断是 dalvik 还是 art 并返回相应的so
        ALOGE("Could not determine runtime, not loading Xposed");
        return;
    }

    // Load the suitable libxposed_*.so for it
    void* xposedLibHandle = dlopen(xposedLibPath, RTLD_NOW);
    //...
    
    //获取 xposedInitLib 函数指针
    *(void **) (&xposedInitLib) = dlsym(xposedLibHandle, "xposedInitLib");
    //...

	//执行 xposedInitLib 函数，该函数内修改了xposed->onVmCrated 函数地址
    if (xposedInitLib(xposed)) {
        xposed->onVmCreated(env);
    }
}
```
determineRuntime 函数判断当前运行的环境是 dalvik 还是 art,如果是 dalvik 返回 `libxposed_dalvik.so`,如果是 art 返回 `libxposed_art.so`。通过 dlsym 获取 xposedInitLib 函数地址并执行该函数。

**xposedInitLib(XposedShared* )**

```c++
bool xposedInitLib(XposedShared* shared) {
    xposed = shared;
    xposed->onVmCreated = &onVmCreatedCommon;
    return true;
}
```
这里操作很简单，只是修改了 xposed->onVmCreated 函数指针，所以在xposed::onVmCreated(JNIEnv* ) 最后一行实际执行的是 onVmCreatedCommon。

**onVmCreatedCommon(JNIEnv* )**

```c++
void onVmCreatedCommon(JNIEnv* env) {
    if (!initXposedBridge(env) || !initZygoteService(env)) {
        return;
    }
    //...

    if (!onVmCreated(env)) {
        return;
    }
	//..
}
```
initXposedBridge 和 initZygoteService 主要是注册了相关的JNI方法。同时获取了一个比较关键的 methodID:`handleHookedMethod`。这个函数负责处理被 hook 函数的回调。

在 onVmCreatedCommon 的最后调用了 onVmCreated(env) 这个函数是在 libxposed_dalvik/art.so 中定义的。

**onVmCreated(JNIEnv* )**

```c++
//dalvik
bool onVmCreated(JNIEnv* env) {
    //...
	//注册 invokeOriginalMethodNative JNI函数
    Method* xposedInvokeOriginalMethodNative = (Method*) env->GetStaticMethodID(classXposedBridge, "invokeOriginalMethodNative",
        "(Ljava/lang/reflect/Member;I[Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;");
    //...
    dvmSetNativeFunc(xposedInvokeOriginalMethodNative, XposedBridge_invokeOriginalMethodNative, NULL);
    //...
    return true;
}

//art
bool onVmCreated(JNIEnv*) {
    //作者重新了libart.so 并重新定义了ArtMetod,这里添加了 jclass 和 methodID
    ArtMethod::xposed_callback_class = classXposedBridge;
    ArtMethod::xposed_callback_method = methodXposedBridgeHandleHookedMethod;
    return true;
}
```
到这里替换后的 app_process 功能基本上结束，主要做了三件事：

- 将 XposedBridge.jar 添加到 CLASSPATH
- 注入 libxposed_dalik/art.so 并执行 xposedInitLib
- 注册相关的 JNI 函数

### 2.被 Hook 函数调用流程
被 Hook 函数调用主要涉及三个函数：

- hookMethodNative: 修改原始函数结构
- handleHookedMethod: 处理被 hook 函数的回调
- invokeOriginalMethodNative: 执行原始函数

因为 dalvik 和 art 实现方式不同，所以对他们的处理也是不一样。

#### dalvik 虚拟机

回到 XposedBridge.hookMethodNative 这个函数修改了 native 的 Method 结构。

```c++
void XposedBridge_hookMethodNative(JNIEnv* env, jclass clazz, jobject reflectedMethodIndirect,
            jobject declaredClassIndirect, jint slot, jobject additionalInfoIndirect) {
    // ...
    // 通过 slot 获取原始函数的指针
    Method* method = dvmSlotToMethod(declaredClass, slot);
    //..
    
    // Save a copy of the original method and other hook info
    XposedHookInfo* hookInfo = (XposedHookInfo*) calloc(1, sizeof(XposedHookInfo));
    memcpy(hookInfo, method, sizeof(hookInfo->originalMethodStruct));
    hookInfo->reflectedMethod = dvmDecodeIndirectRef(dvmThreadSelf(), env->NewGlobalRef(reflectedMethodIndirect));
    hookInfo->additionalInfo = dvmDecodeIndirectRef(dvmThreadSelf(), env->NewGlobalRef(additionalInfoIndirect));

    // Replace method with our own code
    SET_METHOD_FLAG(method, ACC_NATIVE);
    method->nativeFunc = &hookedMethodCallback; //nativeFunc 指向hookedMethodCallback函数地址
    method->insns = (const u2*) hookInfo; //保留了原始函数和hook的信息
    method->registersSize = method->insSize;
    method->outsSize = 0;
    //...
}
```
这里需要理解 两个变量的含义 `method->nativeFunc` 和 `method->insns`，查看源码：  
[dalvik/vm/oo/Object.h](http://androidxref.com/4.4.2_r1/xref/dalvik/vm/oo/Object.h):

```c++
struct Method {
    ...
    /*
     * The remaining items are not used for abstract or native methods.
     * (JNI is currently hijacking "insns" as a function pointer, set
     * after the first call.  For internal-native this stays null.)
     */

    /* the actual code */
    const u2*       insns;          /* instructions, in memory-mapped .dex */

    /*
     * JNI: native method ptr; could be actual function or a JNI bridge.  We
     * don't currently discriminate between DalvikBridgeFunc and
     * DalvikNativeFunc; the former takes an argument superset (i.e. two
     * extra args) which will be ignored.  If necessary we can use
     * insns==NULL to detect JNI bridge vs. internal native.
     */
    DalvikBridgeFunc nativeFunc;
	...
};
```
nativeFunc 保存的是 JNI 函数对应的 native 代码。而且通过判断insns==NULL 可以判断一个函数是 JNI bridge 还是 internal native。xposed 将 HookInfo 地址保存在 insns。

所以在调用被 Hook 函数时，会先调用 nativeFunc 保存的地址的函数，也就是 libxposed_dalvik.so 中定义的 hookedMethodCallback：

**hookedMethodCallback(const u4*, JValue*, const Method*, ::Thread*)**

```c++
void hookedMethodCallback(const u4* args, JValue* pResult, const Method* method, ::Thread* self) {
    ...
	// 从 method->insns 取出 HookInfo
    XposedHookInfo* hookInfo = (XposedHookInfo*) method->insns;
    Method* original = (Method*) hookInfo;
    Object* originalReflected = hookInfo->reflectedMethod;
    Object* additionalInfo = hookInfo->additionalInfo;

    // convert/box arguments 整理参数
    ...
    
    // call the Java handler function 调用 XposedBridge.handleHookedMethod()
    JValue result;
    dvmCallMethod(self, (Method*) methodXposedBridgeHandleHookedMethod, NULL, &result,
        originalReflected, (int) original, additionalInfo, thisObject, argsArray);

    ...

    // return result with proper type 获取返回值
    ...
}
```
上面函数通过 dvmCallMethod 调用了 XposedBridge.handleHookedMethod 并把 HookInfo 作为参数传过去。
**XposedBridge.handleHookedMethod()**

```java
	private static Object handleHookedMethod(Member method, int originalMethodId, Object additionalInfoObj,
			Object thisObject, Object[] args) throws Throwable {
		AdditionalHookInfo additionalInfo = (AdditionalHookInfo) additionalInfoObj;
		//如果关闭hook，或者callback个数为0，直接调用invokeOriginalMethodNative
		...

		MethodHookParam param = new MethodHookParam();
		param.method = method;
		param.thisObject = thisObject;
		param.args = args;

		// call "before method" callbacks
		int beforeIdx = 0;
		do {
			try {
				((XC_MethodHook) callbacksSnapshot[beforeIdx]).beforeHookedMethod(param);
			} catch (Throwable t) {
				XposedBridge.log(t);

				// reset result (ignoring what the unexpectedly exiting callback did)
				param.setResult(null);
				param.returnEarly = false;
				continue;
			}

			if (param.returnEarly) {
				// skip remaining "before" callbacks and corresponding "after" callbacks
				beforeIdx++;
				break;
			}
		} while (++beforeIdx < callbacksLength);

		// call original method if not requested otherwise
		if (!param.returnEarly) {
			try {
				param.setResult(invokeOriginalMethodNative(method, originalMethodId,
						additionalInfo.parameterTypes, additionalInfo.returnType, param.thisObject, param.args));
			} catch (InvocationTargetException e) {
				param.setThrowable(e.getCause());
			}
		}

		// call "after method" callbacks
		int afterIdx = beforeIdx - 1;
		do {
			Object lastResult =  param.getResult();
			Throwable lastThrowable = param.getThrowable();

			try {
				((XC_MethodHook) callbacksSnapshot[afterIdx]).afterHookedMethod(param);
			} catch (Throwable t) {
				XposedBridge.log(t);

				// reset to last result (ignoring what the unexpectedly exiting callback did)
				if (lastThrowable == null)
					param.setResult(lastResult);
				else
					param.setThrowable(lastThrowable);
			}
		} while (--afterIdx >= 0);

		// return
		if (param.hasThrowable())
			throw param.getThrowable();
		else
			return param.getResult();
	}
``` 
函数解析了 AdditionalHookInfo, 根据保存的 callback, 依次调用XC_MethodHook.beforeHookedMethod、invokeOriginalMethodNative、XC_MethodHook.afterHookedMethod

invokeOriginalMethodNative 是通过修改 Method.invokeNative 对于的 native 方法，获取到原始函数的返回值

**XposedBridge_invokeOriginalMethodNative(const u4*, JValue*,const Method*, ::Thread*)**

```C++
/**
 * Simplified copy of Method.invokeNative(), but calls the original (non-hooked) method
 * and has no access checks. Used to call the real implementation of hooked methods.
 */
void XposedBridge_invokeOriginalMethodNative(const u4* args, JValue* pResult,
            const Method* method, ::Thread* self) {
    ...
    
    ArrayObject* params = (ArrayObject*) args[2];
    ClassObject* returnType = (ClassObject*) args[3];
    Object* thisObject = (Object*) args[4]; // null for static methods
    ArrayObject* argList = (ArrayObject*) args[5];

    // invoke the method
    pResult->l = dvmInvokeMethod(thisObject, meth, argList, params, returnType, true);
    return;
}
```
到这里 dalvik 虚拟机的 Hook Method 流程就结束了。

#### art 虚拟机
再回到 XposedBridge.hookMethodNative 这个函数，对于的 native 的处理

**XposedBridge_hookMethodNative(JNIEnv* , jclass, jobject,
            jobject, jint, jobject)**
            
```C++
void XposedBridge_hookMethodNative(JNIEnv* env, jclass, jobject javaReflectedMethod,
            jobject, jint, jobject javaAdditionalInfo) {
    //...

    // Get the ArtMethod of the method to be hooked.
    ScopedObjectAccess soa(env);
    ArtMethod* artMethod = ArtMethod::FromReflectedMethod(soa, javaReflectedMethod);

    // Hook the method
    artMethod->EnableXposedHook(soa, javaAdditionalInfo);
}
```
函数很简单只是将 javaAdditonalInfo 添加到 artMethod。但是正常的ArtMethod 结构是没有 EnableXposedHook 方法的。这里是作者重新编译了 libart.so, 修改了 ArtMethod 的定义代码。

```C++
void ArtMethod::EnableXposedHook(ScopedObjectAccess& soa, jobject additional_info) {
  ...

  // Create a backup of the ArtMethod object
  auto* cl = Runtime::Current()->GetClassLinker();
  ArtMethod* backup_method = cl->AllocArtMethodArray(soa.Self(), 1);
  backup_method->CopyFrom(this, cl->GetImagePointerSize());
  backup_method->SetAccessFlags(backup_method->GetAccessFlags() | kAccXposedOriginalMethod);

  // Create a Method/Constructor object for the backup ArtMethod object
  mirror::AbstractMethod* reflect_method;
  if (IsConstructor()) {
    reflect_method = mirror::Constructor::CreateFromArtMethod(soa.Self(), backup_method);
  } else {
    reflect_method = mirror::Method::CreateFromArtMethod(soa.Self(), backup_method);
  }
  reflect_method->SetAccessible<false>(true);

  // Save extra information in a separate structure, stored instead of the native method
  XposedHookInfo* hookInfo = reinterpret_cast<XposedHookInfo*>(calloc(1, sizeof(XposedHookInfo)));
  hookInfo->reflectedMethod = soa.Vm()->AddGlobalRef(soa.Self(), reflect_method);
  hookInfo->additionalInfo = soa.Env()->NewGlobalRef(additional_info);
  hookInfo->originalMethod = backup_method;
  
  //通过setEntryPointFromJni 将 XposedHookInfo 写入当前函数
  SetEntryPointFromJni(reinterpret_cast<uint8_t*>(hookInfo));

  ...
  //重新设置 EntryPointFromQuickCompiledCode 值为GetQuickProxyInvokeHandler 的返回值art_quick_proxy_invoke_handler 以此达到hook的目的
  SetEntryPointFromQuickCompiledCode(GetQuickProxyInvokeHandler());
  //设置当前方法以机器指令执行
  SetEntryPointFromInterpreter(artInterpreterToCompiledCodeBridge);
  //将此方法设置为 非native(~kAccNative) 方法，且为xposed hook 的方法（kAccXposedHookedMethod）
  SetAccessFlags((GetAccessFlags() & ~kAccNative & ~kAccSynchronized) | kAccXposedHookedMethod);
}

```
 EnableXposedHook，会创建一个hookInfo 将original、before、after 方法存入，然后通过 SetEntryPointFromJni 方法将hookinfo 保存到ArtMethod 中。

在之后 通过SetEntryPointFromInterpreter 方法强制设置 java 方法为，本地机器码执行。
    
通过SetEntryPointFromQuickCompiledCode 改变机器码执行时的函数入口为 art_quick_proxy_invoke_handler 到此函数的整个hook 流程就已经完成。

所以在调用被 Hook 函数时，会先调用 ArtMethod.invoke, 经过 SetEntryPointFromQuickCompiledCode 的设置，最后会调用artQuickProxyInvokeHandler(这一段没看懂)，在 artQuickProxyInvokeHandler 中调用了 InvokeXposedHandleHookedMethod 到这里和 dalvik 一样了。

整个流程: ArtMethod::invoke -> artQuickProxyInvokeHandler -> InvokeXposedHandleHookedMethod -> XposedBridge.handleHookedMethod -> invokeOriginalMethodNative


## 0x05 检测方式

### 1.安装包检测
Xposed 框架需要安装 XposedInstaller 进行管理，可以检测 是否安装了 XposedInstaller。不过该方法准确性不高，有可能 Xposed 框架没有运行。

### 2.错误堆栈检测
Xposed 框架在 app_process 中注入了 XposedBridge.jar 所以在错误堆栈中会有 `de.robv.android.xposed.XposedBridge` 相关的信息。

### 3.maps 文件检测
Xposed 框架在 zygote 进程中注入了 libxposed_dalvik/art.so 和 XposedBridge.jar 所以在每个应用启动的时候 maps 文件都会包含上面两个linker。

```bash
angler:/ # cat /proc/6429/maps | egrep 'Xposed|xposed'
ab05c000-ab069000 r-xp 00000000 103:0b 2424                              /system/bin/app_process32_xposed
ab06a000-ab06c000 r--p 0000d000 103:0b 2424                              /system/bin/app_process32_xposed
ab06c000-ab06d000 rw-p 0000f000 103:0b 2424                              /system/bin/app_process32_xposed
e24a3000-e27c6000 r--p 00000000 fd:00 318935                             /data/dalvik-cache/arm/data@app@com.example.xposed_plugin-2@base.apk@classes.dex
e27c6000-e2960000 r-xp 00323000 fd:00 318935                             /data/dalvik-cache/arm/data@app@com.example.xposed_plugin-2@base.apk@classes.dex
e298d000-e298e000 r--p 004bd000 fd:00 318935                             /data/dalvik-cache/arm/data@app@com.example.xposed_plugin-2@base.apk@classes.dex
e298e000-e298f000 rw-p 004be000 fd:00 318935                             /data/dalvik-cache/arm/data@app@com.example.xposed_plugin-2@base.apk@classes.dex
e57d2000-e582c000 r--p 00000000 fd:00 318929                             /data/dalvik-cache/arm/system@framework@XposedBridge.jar@classes.dex
e582c000-e586d000 r-xp 0005a000 fd:00 318929                             /data/dalvik-cache/arm/system@framework@XposedBridge.jar@classes.dex
e5873000-e5874000 r--p 0009b000 fd:00 318929                             /data/dalvik-cache/arm/system@framework@XposedBridge.jar@classes.dex
e5874000-e5875000 rw-p 0009c000 fd:00 318929                             /data/dalvik-cache/arm/system@framework@XposedBridge.jar@classes.dex
ef103000-ef104000 r--s 00019000 103:0b 2422                              /system/framework/XposedBridge.jar
ef13c000-ef145000 r-xp 00000000 103:0b 2432                              /system/lib/libxposed_art.so
ef145000-ef146000 r--p 00008000 103:0b 2432                              /system/lib/libxposed_art.so
ef146000-ef147000 rw-p 00009000 103:0b 2432                              /system/lib/libxposed_art.so
ef148000-ef14a000 r--p 00000000 fd:00 318930                             /data/dalvik-cache/arm/data@dalvik-cache@xposed_XResourcesSuperClass.dex
ef14b000-ef14c000 r--p 00002000 fd:00 318930                             /data/dalvik-cache/arm/data@dalvik-cache@xposed_XResourcesSuperClass.dex
ef14c000-ef14d000 rw-p 00003000 fd:00 318930                             /data/dalvik-cache/arm/data@dalvik-cache@xposed_XResourcesSuperClass.dex
```
### 4.app_process 检测
Xposed 会替换原始的 app_process 并备份原始的文件，dalvik下会有app_process.orig 文件。art下会多出四个文件。

- app_process32_xposed
- app_process32_original
- app_process64_xposed
- app_process64_original



```bash
# dalvik
-rwxr-xr-x root     shell       21980 2017-08-28 02:31 app_process
-rwxr-xr-x root     shell        9560 2014-06-13 07:06 app_process.orig

# art
lrwxr-xr-x  1 root shell     13 2009-01-01 16:00 app_process -> app_process64
lrwxrwxrwx  1 root root      32 2017-01-01 23:07 app_process32 -> /system/bin/app_process32_xposed
-rwxr-xr-x  1 root shell  22040 2009-01-01 16:00 app_process32_original
-rwxr-xr-x  1 root shell  99772 2017-01-01 23:07 app_process32_xposed
lrwxrwxrwx  1 root root      32 2017-01-01 23:07 app_process64 -> /system/bin/app_process64_xposed
-rwxr-xr-x  1 root shell  18600 2009-01-01 16:00 app_process64_original
-rwxr-xr-x  1 root shell 113904 2017-01-01 23:07 app_process64_xposed
```

除了文件名，app_process 文件内部也包含了很多 xposed 字符相关的特征

### 5.修饰符检测(dalvik)
dalvik 虚拟机通过修改 nativeFunc 和 insns 地址实现了 Hook 但是同时也会把被 Hook 函数变了 native 函数。

### 6.被 Hook 函数和字段检测
XposedBridge.jar 中缓存了被 Hook 函数和字段，如:

- XposedHelpers.fieldCache: 被 Hook 的所有字段
- XposedHelpers.methodCache: 被 Hook 的所有函数
- XposedBridge.sHookedMethodCallbacks: 被 Hook 的函数及对应的 Callback。
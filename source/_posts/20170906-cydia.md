---
title: Cydia Substrate(Android) 检测方法
tags: [android, hook, cydia]
toc: true
date: 2017-09-06 23:14:43
categories: android
description: 相较于 Xposed 框架 Cydia Substrate 支持 Hook Native 代码，并且也可以做成 apk 插件。但是官方介绍中 Cydia Substrate 框架只支持 4.0 一下的系统，估计作者也不更新了。

---
## 0x00 简介

## 0x01 文件特征扫描
**1. 安装包检测**    
Cydia Substrate 框架的特定安装包，包名："com.saurik.substrate"。

**2. maps 文件内容检测**    
主要扫描注入的 so 文件，特征字符串以 `substrate` 为主。

**3. /system/bin 下文件**    
安装后添加了两个 substrate 的 lib 链接库：

```bash
lrwxrwxrwx root     root              2017-08-29 21:18 libsubstrate-dvm.so -> /data/data/com.saurik.substrate/lib/libsubstrate-dvm.so
lrwxrwxrwx root     root              2017-08-29 21:18 libsubstrate.so -> /data/data/com.saurik.substrate/lib/libsubstrate.so
```


## 0x02 Framework Class 扫描

**1. 错误堆栈**

**PS:该方式目前的方案可以改进**

正常错误堆栈：

```java
java.lang.Exception: AntiHook
     at com.example.gnaixx.antihook.detect.DetectSubstrate.detectByException(DetectSubstrate.java:38)
     at com.example.gnaixx.antihook.MainActivity.detectSubstrate(MainActivity.java:94)
     at com.example.gnaixx.antihook.MainActivity.onClick(MainActivity.java:41)
     at android.view.View.performClick(View.java:5769)
     at android.view.View$PerformClick.run(View.java:22946)
     at android.os.Handler.handleCallback(Handler.java:836)
     at android.os.Handler.dispatchMessage(Handler.java:103)
     at android.os.Looper.loop(Looper.java:203)
     at android.app.ActivityThread.main(ActivityThread.java:6451)
     at java.lang.reflect.Method.invoke(Native Method)
     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1134)
     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:995)

```
正常的错误堆栈底层只调用了一次 `com.android.internal.os.ZygoteInit.main`
方法。

异常错误堆栈1(非被 Hook 函数 Throw Exception)：

```java
java.lang.Exception: AntiHook
     .......
     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:785)
     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:601)
     at com.android.internal.os.ZygoteInit.main(Native Method)
     at dalvik.system.NativeStart.main(Native Method)
```
非被 Hook 函数 Throw Exception 时，`dalvik.system.NativeStart.main` 调用后会出现2次 `com.android.internal.os.ZygoteInit.main`。

异常错误堆栈2(被 Hook 函数 Throw Exception):

```java
 java.lang.Exception: AntiHook
     at com.example.gnaixx.antihook.util.TestUtil.test1(TestUtil.java:13)
     at com.saurik.substrate._MS$MethodPointer.invoke(Native Method)
     at com.saurik.substrate.MS$MethodAlteration.invoke(MS.java:99)
     at com.example.substrate_plugin.Main$1$1.invoked(Main.java:26)
     at com.example.substrate_plugin.Main$1$1.invoked(Main.java:20)
     at com.saurik.substrate.MS$2.invoked(MS.java:68)
     at com.example.gnaixx.antihook.util.TestUtil.test1(Native Method)
     ......
     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:785)
     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:601)
     at com.android.internal.os.ZygoteInit.main(Native Method)
     at dalvik.system.NativeStart.main(Native Method)
```
如果是被 Hook 的函数 Throw Exception 除了上述的特征2次 `com.android.internal.os.ZygoteInit.main`。在调用的函数前还有一段特征:

```java
......
1. at com.saurik.substrate._MS$MethodPointer.invoke(Native Method)
2. at com.saurik.substrate.MS$MethodAlteration.invoke(MS.java:99)
3. at com.example.substrate_plugin.Main$1$1.invoked(Main.java:26)
4. at com.example.substrate_plugin.Main$1$1.invoked(Main.java:20)
5. at com.saurik.substrate.MS$2.invoked(MS.java:68)
......
```
1、2、5 行是 Cydia Substrate framework 中的 Class，3、4 为插件的 Class。所以如果错误堆栈中出现了 1、2、5 的类名也可以作为一个特征。

**2. Load Class**

通过错误堆栈可以看出一部分注入的 Java 类，可以通过 frida 将框架所有调用的 Class 扫出来：

```python
import frida
import sys


device = frida.get_usb_device()
front_app = device.get_frontmost_application()
print(front_app)
session = device.attach(front_app.identifier)

def on_message(message, data):
    if message['type'] == 'send':
        print("[*] {0}".format(message['payload']))
    else:
        print(message)

jscode = """
var classes = Java.enumerateLoadedClassesSync();
for(var i=0; i<classes.length; i++){
    send(classes[i]);
}
"""
script = session.create_script(jscode)
script.on('message', on_message)
print('[*] Running CTF')
script.load()
sys.stdin.read()
```

扫出来的相关 Class 主要有以下几个：

```bash
[*] Lcom/saurik/substrate/_MS$MethodHook;
[*] Lcom/saurik/substrate/_MS$MethodPointer;
[*] Lcom/saurik/substrate/SubstrateClassLoader;
[*] Lcom/saurik/substrate/MS$ClassLoadHook;
[*] Lcom/saurik/substrate/_MS$ClassLoadHook;
[*] Lcom/saurik/substrate/MS$1;
[*] Lcom/saurik/substrate/MS$2;
[*] Lcom/saurik/substrate/MS;
[*] Lcom/saurik/substrate/_MS;
```
这几个类如果通过 ClassLoader.loadClass 或者 Class.forClass 获取都会找不到对应的类，除了 `SubstrateClassLoader`,通过在插件中递归打印它自己的 ClassLoader：

```bash
com.saurik.substrate.SubstrateClassLoader[DexPathList[[zip file "/data/app/com.example.substrate_plugin-1.apk"],nativeLibraryDirectories=[/vendor/lib, /system/lib]]]
dalvik.system.PathClassLoader[DexPathList[[directory "."],nativeLibraryDirectories=[/vendor/lib, /system/lib]]]
java.lang.BootClassLoader@41643fd0
```
SubstrateClassLoader 继承了 PathClassLoader 并且加载了其他插件，所以可以通过检测SubstrateClassLoader 来判断:

```java
ClassLoader.getSystemClassLoader().loadClass("com.saurik.substrate.SubstrateClassLoader");
```

## 0x03 Java 被 Hook 函数扫描

substrate hook 方式和


## 0x04 Native 被 Hook 函数扫描
**分析 Native Hook 函数特征**

通过编写 Substrate 插件 hook native 函数。利用 IDA 动态调试查看函数指令和机器码：
![hook](/blog_images/20170906/method-hook.png)

```bash
78 47 c0 46 
04 f0 1f e5 
8d a0 54 41 
10 bc 01 b4
20 bc 0b 90 
......

```
指令 `BX PC` 执行了跳转操作，最后根据动态调试结果, `41540a8d`(Little-Endian)即为函数跳转后的执行地址，也就是hook后修改的函数地址。

原始指令集和对应的机器码：
![orignal](/blog_images/20170906/method-orignal.png)

```bash
b0 b5 02 af 
8c b0 04 b4 
08 bc 02 b4
10 bc 01 b4
20 bc 0b 90
.......

```

对比原始函数的机器码和 hook 后函数的机器，可以发现函数的前 12 个字节被修改了。

**识别方案**

- 通过获取函数地址
- 分析地址前四个机器码是否为 `78 47 c0 46`(跳转指令)
- 获取第 9 位开始的地址
- 通过地址和 maps 中内存信息匹配获取到注入的 so
